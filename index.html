<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pebble Emulator</title>
    <script src="coi-serviceworker.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; font-size: 18px; }
        #status {
            margin-bottom: 10px;
            padding: 5px 10px;
            background: #16213e;
            border-radius: 4px;
            font-size: 14px;
        }
        #progress-bar {
            width: 400px;
            height: 6px;
            background: #16213e;
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
            display: none;
        }
        #progress-fill {
            height: 100%;
            background: #4cc9f0;
            border-radius: 3px;
            width: 0%;
            transition: width 0.2s;
        }
        #display-wrapper {
            position: relative;
            margin-bottom: 15px;
        }
        canvas#canvas {
            image-rendering: pixelated;
            border: 2px solid #333;
            border-radius: 8px;
            width: 400px;
            height: 456px;
        }
        #buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        #buttons button {
            padding: 8px 16px;
            background: #16213e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            user-select: none;
        }
        #buttons button:active, #buttons button.pressed { background: #0f3460; }
        #buttons button:hover { border-color: #888; }
        #console-wrapper {
            width: 600px;
            max-height: 300px;
        }
        #console-wrapper h3 {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        #console {
            width: 100%;
            height: 250px;
            background: #0a0a0a;
            color: #0f0;
            font-size: 12px;
            padding: 8px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .key-hint {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>Pebble Emulator</h1>
    <div id="status">Loading...</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>

    <div id="display-wrapper">
        <canvas id="canvas" width="200" height="228"></canvas>
    </div>

    <div id="buttons">
        <button id="btn-back" title="Back (Escape)">Back</button>
        <button id="btn-up" title="Up (Arrow Up)">Up</button>
        <button id="btn-select" title="Select (Enter)">Select</button>
        <button id="btn-down" title="Down (Arrow Down)">Down</button>
    </div>
    <div class="key-hint">Keys: Escape=Back, Up/Down=Navigate, Enter=Select</div>

    <div id="console-wrapper">
        <h3>Serial Console</h3>
        <div id="console"></div>
    </div>

    <script>
        var ASSET_BASE = 'web/';

        var statusEl = document.getElementById('status');
        var consoleEl = document.getElementById('console');
        var progressBar = document.getElementById('progress-bar');
        var progressFill = document.getElementById('progress-fill');

        function log(msg) {
            consoleEl.textContent += msg + '\n';
            if (consoleEl.textContent.length > 100000) {
                consoleEl.textContent = consoleEl.textContent.slice(-50000);
            }
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        function setStatus(msg) {
            statusEl.textContent = msg;
            log('[status] ' + msg);
        }

        function showProgress(pct) {
            progressBar.style.display = 'block';
            progressFill.style.width = pct + '%';
        }

        function hideProgress() {
            progressBar.style.display = 'none';
        }

        async function fetchWithProgress(url, label, expectedSize) {
            var resp = await fetch(url);
            if (!resp.ok) throw new Error(label + ': HTTP ' + resp.status);

            var reader = resp.body.getReader();
            var total = parseInt(resp.headers.get('content-length')) || expectedSize;
            var received = 0;
            var chunks = [];

            while (true) {
                var result = await reader.read();
                if (result.done) break;
                chunks.push(result.value);
                received += result.value.length;
                if (total) {
                    var pct = Math.round(received / total * 100);
                    setStatus(label + '... ' + Math.round(received / 1024) + 'KB');
                    showProgress(pct);
                }
            }

            hideProgress();
            var data = new Uint8Array(received);
            var offset = 0;
            for (var i = 0; i < chunks.length; i++) {
                data.set(chunks[i], offset);
                offset += chunks[i].length;
            }
            return data;
        }

        var runtimeReady = false;

        var Module = {
            canvas: document.getElementById('canvas'),
            noInitialRun: false,
            arguments: [
                '-machine', 'pebble-snowy-emery-bb',
                '-display', 'none',
                '-monitor', 'none',
                '-parallel', 'none',
                '-kernel', '/firmware/qemu_micro_flash.bin',
                '-drive', 'if=none,id=spi-flash,file=/firmware/qemu_spi_flash.bin,format=raw',
                '-serial', 'null',
                '-serial', 'null',
                '-serial', 'null',
                '-icount', 'shift=auto',
            ],
            print: function(text) {
                log(text);
            },
            printErr: function(text) {
                if (text.indexOf('exception') >= 0) return;
                if (text.indexOf('Exception') >= 0) return;
                if (text.indexOf('unsupported') >= 0) return;
                if (text.indexOf('unimplemented') >= 0) return;
                if (text.indexOf('Not implemented') >= 0) return;
                if (text.indexOf('...') === 0) return;
                log('[err] ' + text);
            },
            onRuntimeInitialized: function() {
                setStatus('QEMU runtime initialized, booting Pebble firmware...');
                runtimeReady = true;
            },
            locateFile: function(path) {
                return ASSET_BASE + path;
            },
            preRun: [],
        };

        async function loadAndStart() {
            try {
                setStatus('Fetching micro flash (827KB)...');
                var microData = await fetchWithProgress(
                    ASSET_BASE + 'qemu_micro_flash.bin', 'Micro flash', 846848
                );
                log('Downloaded micro flash: ' + microData.length + ' bytes');

                setStatus('Fetching SPI flash (16MB)...');
                var spiData = await fetchWithProgress(
                    ASSET_BASE + 'qemu_spi_flash.bin', 'SPI flash', 16777216
                );
                log('Downloaded SPI flash: ' + spiData.length + ' bytes');

                Module.preRun.push(function() {
                    try { FS.mkdir('/firmware'); } catch(e) {}
                    FS.writeFile('/firmware/qemu_micro_flash.bin', microData);
                    FS.writeFile('/firmware/qemu_spi_flash.bin', spiData);
                    log('Firmware written to virtual filesystem');
                });

                setStatus('Loading QEMU WASM module (33MB)...');
                var script = document.createElement('script');
                script.src = ASSET_BASE + 'qemu-system-arm.js';
                script.onerror = function() {
                    setStatus('Failed to load qemu-system-arm.js');
                };
                document.body.appendChild(script);

            } catch(e) {
                setStatus('Error: ' + e.message);
                log(e.stack || e.toString());
            }
        }

        loadAndStart();

        // ================================================================
        // Framebuffer rendering
        // ================================================================
        var lastFrameCount = 0;
        var totalFrames = 0;
        var canvasCtx = document.getElementById('canvas').getContext('2d');

        function renderLoop() {
            if (!runtimeReady) return;
            try {
                var frameCount = Module._pebble_display_frame_count();
                if (frameCount === lastFrameCount) return;
                lastFrameCount = frameCount;
                totalFrames++;

                var width = Module._pebble_display_width();
                var height = Module._pebble_display_height();
                var stride = Module._pebble_display_stride();
                var dataPtr = Module._pebble_display_data();

                if (!dataPtr || !width || !height) return;

                if (totalFrames === 1) {
                    setStatus('Display active: ' + width + 'x' + height);
                }

                var imgData = canvasCtx.createImageData(width, height);
                var pixels = imgData.data;

                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var srcOff = dataPtr + y * stride + x * 4;
                        var dstOff = (y * width + x) * 4;
                        pixels[dstOff + 0] = Module.HEAPU8[srcOff + 2]; // R
                        pixels[dstOff + 1] = Module.HEAPU8[srcOff + 1]; // G
                        pixels[dstOff + 2] = Module.HEAPU8[srcOff + 0]; // B
                        pixels[dstOff + 3] = 255;                       // A
                    }
                }
                canvasCtx.putImageData(imgData, 0, 0);
            } catch(e) {}
        }
        setInterval(renderLoop, 50);

        // ================================================================
        // Button input
        // ================================================================
        var buttonState = 0;
        var BUTTON_BACK   = 1 << 0;
        var BUTTON_UP     = 1 << 1;
        var BUTTON_SELECT = 1 << 2;
        var BUTTON_DOWN   = 1 << 3;

        var keyMap = {
            'Escape':     BUTTON_BACK,
            'Backspace':  BUTTON_BACK,
            'ArrowUp':    BUTTON_UP,
            'ArrowDown':  BUTTON_DOWN,
            'Enter':      BUTTON_SELECT,
            'ArrowRight': BUTTON_SELECT,
            'ArrowLeft':  BUTTON_BACK,
            'q':          BUTTON_BACK,
            'w':          BUTTON_UP,
            's':          BUTTON_SELECT,
            'x':          BUTTON_DOWN,
        };

        var buttonStateAddr = 0;

        function updateButtons(bit, pressed) {
            if (pressed) {
                buttonState |= bit;
            } else {
                buttonState &= ~bit;
            }
            if (!runtimeReady) return;
            if (buttonStateAddr) {
                Atomics.store(Module.HEAPU32, buttonStateAddr, buttonState);
            } else if (Module._pebble_button_state_addr) {
                var addr = Module._pebble_button_state_addr();
                if (addr) {
                    buttonStateAddr = addr >> 2;
                    Atomics.store(Module.HEAPU32, buttonStateAddr, buttonState);
                    log('[button] Direct memory at 0x' + addr.toString(16));
                }
            }
        }

        var keyHoldTimers = {};

        document.addEventListener('keydown', function(e) {
            var bit = keyMap[e.key];
            if (bit !== undefined) {
                e.preventDefault();
                if (e.repeat) return;
                updateButtons(bit, true);
                if (keyHoldTimers[e.key]) clearTimeout(keyHoldTimers[e.key]);
                keyHoldTimers[e.key] = null;
            }
        });

        document.addEventListener('keyup', function(e) {
            var bit = keyMap[e.key];
            if (bit !== undefined) {
                e.preventDefault();
                if (keyHoldTimers[e.key]) clearTimeout(keyHoldTimers[e.key]);
                keyHoldTimers[e.key] = setTimeout(function() {
                    updateButtons(bit, false);
                    keyHoldTimers[e.key] = null;
                }, 1000);
            }
        });

        var btnMap = {
            'btn-back':   BUTTON_BACK,
            'btn-up':     BUTTON_UP,
            'btn-select': BUTTON_SELECT,
            'btn-down':   BUTTON_DOWN,
        };

        Object.keys(btnMap).forEach(function(id) {
            var el = document.getElementById(id);
            var bit = btnMap[id];
            el.addEventListener('mousedown', function(e) {
                e.preventDefault();
                el.classList.add('pressed');
                updateButtons(bit, true);
            });
            el.addEventListener('mouseup', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
            el.addEventListener('mouseleave', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
            el.addEventListener('touchstart', function(e) {
                e.preventDefault();
                el.classList.add('pressed');
                updateButtons(bit, true);
            });
            el.addEventListener('touchend', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
        });
    </script>
</body>
</html>
