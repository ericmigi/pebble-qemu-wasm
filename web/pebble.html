<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pebble Emulator (QEMU WASM)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; font-size: 18px; }
        #status {
            margin-bottom: 10px;
            padding: 5px 10px;
            background: #16213e;
            border-radius: 4px;
            font-size: 14px;
        }
        #display-wrapper {
            position: relative;
            margin-bottom: 15px;
        }
        canvas#canvas {
            image-rendering: pixelated;
            border: 2px solid #333;
            border-radius: 8px;
            width: 400px;
            height: 456px;
        }
        #buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        #buttons button {
            padding: 8px 16px;
            background: #16213e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            user-select: none;
        }
        #buttons button:active, #buttons button.pressed { background: #0f3460; }
        #buttons button:hover { border-color: #888; }
        #console-wrapper {
            width: 600px;
            max-height: 300px;
        }
        #console-wrapper h3 {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        #console {
            width: 100%;
            height: 250px;
            background: #0a0a0a;
            color: #0f0;
            font-size: 12px;
            padding: 8px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .key-hint {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        #controls {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        #controls select, #controls button {
            background: #16213e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        #controls select { padding: 4px 8px; }
        #controls button { padding: 4px 12px; cursor: pointer; }
        #controls button:hover { border-color: #888; }
        #controls button:disabled { opacity: 0.5; cursor: default; }
    </style>
</head>
<body>
    <h1>Pebble Emulator</h1>
    <div id="controls">
        <label for="fw-select">Firmware:</label>
        <select id="fw-select">
            <option value="sdk" selected>SDK PebbleOS</option>
            <option value="full">Full PebbleOS</option>
        </select>
        <button id="btn-boot">Boot</button>
    </div>
    <div id="status">Select firmware and click Boot</div>

    <div id="display-wrapper">
        <!-- Emery: 200x228, CSS scaled 2x -->
        <canvas id="canvas" width="200" height="228"></canvas>
    </div>

    <div id="buttons">
        <button id="btn-back" title="Back (Escape)">Back</button>
        <button id="btn-up" title="Up (Arrow Up)">Up</button>
        <button id="btn-select" title="Select (Enter)">Select</button>
        <button id="btn-down" title="Down (Arrow Down)">Down</button>
    </div>
    <div class="key-hint">Keys: Escape=Back, Up/Down=Navigate, Enter=Select</div>

    <div id="console-wrapper">
        <h3>Serial Console</h3>
        <div id="console"></div>
    </div>

    <script>
        var statusEl = document.getElementById('status');
        var consoleEl = document.getElementById('console');
        var bootBtn = document.getElementById('btn-boot');
        var fwSelect = document.getElementById('fw-select');

        function log(msg) {
            consoleEl.textContent += msg + '\n';
            if (consoleEl.textContent.length > 100000) {
                consoleEl.textContent = consoleEl.textContent.slice(-50000);
            }
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        function setStatus(msg) {
            statusEl.textContent = msg;
            log('[status] ' + msg);
        }

        var runtimeReady = false;

        // Emscripten Module configuration — defined BEFORE loading the .js
        var Module = {
            canvas: document.getElementById('canvas'),
            noInitialRun: false,
            arguments: [
                '-machine', 'pebble-snowy-emery-bb',
                '-display', 'none',
                '-monitor', 'none',
                '-parallel', 'none',
                '-kernel', '/firmware/qemu_micro_flash.bin',
                '-drive', 'if=none,id=spi-flash,file=/firmware/qemu_spi_flash.bin,format=raw',
                '-serial', 'null',
                '-serial', 'null',
                '-serial', 'null',
                '-icount', 'shift=auto',
            ],
            print: function(text) {
                log(text);
            },
            printErr: function(text) {
                // Filter noisy ARMv7M exception trace messages — these cause
                // major performance overhead with thousands of DOM updates/sec
                if (text.indexOf('exception') >= 0) return;
                if (text.indexOf('Exception') >= 0) return;
                if (text.indexOf('unsupported') >= 0) return;
                if (text.indexOf('unimplemented') >= 0) return;
                if (text.indexOf('Not implemented') >= 0) return;
                if (text.indexOf('...') === 0) return;
                log('[err] ' + text);
            },
            onRuntimeInitialized: function() {
                setStatus('QEMU runtime initialized, booting Pebble firmware...');
                runtimeReady = true;
            },
            locateFile: function(path) {
                return path;
            },
            preRun: [],
        };

        bootBtn.addEventListener('click', function() {
            bootBtn.disabled = true;
            fwSelect.disabled = true;
            bootEmulator();
        });

        async function bootEmulator() {
            var variant = fwSelect.value;
            var fwBase = 'firmware/' + variant + '/';

            try {
                setStatus('Fetching micro flash (' + variant + ')...');
                var microResp = await fetch(fwBase + 'qemu_micro_flash.bin');
                if (!microResp.ok) throw new Error('micro flash: ' + microResp.status);
                var microData = new Uint8Array(await microResp.arrayBuffer());
                log('Downloaded micro flash: ' + microData.length + ' bytes');

                setStatus('Fetching SPI flash (16MB)...');
                var spiResp = await fetch(fwBase + 'qemu_spi_flash.bin');
                if (!spiResp.ok) throw new Error('SPI flash: ' + spiResp.status);
                var spiData = new Uint8Array(await spiResp.arrayBuffer());
                log('Downloaded SPI flash: ' + spiData.length + ' bytes');

                Module.preRun.push(function() {
                    try { FS.mkdir('/firmware'); } catch(e) {}
                    FS.writeFile('/firmware/qemu_micro_flash.bin', microData);
                    FS.writeFile('/firmware/qemu_spi_flash.bin', spiData);
                    log('Firmware written to virtual filesystem (' + variant + ')');
                });

                setStatus('Loading QEMU WASM module (33MB)...');
                var script = document.createElement('script');
                script.src = 'qemu-system-arm.js';
                script.onerror = function() {
                    setStatus('Failed to load qemu-system-arm.js');
                };
                document.body.appendChild(script);

            } catch(e) {
                setStatus('Error: ' + e.message);
                log(e.stack || e.toString());
                bootBtn.disabled = false;
                fwSelect.disabled = false;
            }
        }

        // ================================================================
        // Framebuffer rendering loop
        // Polls QEMU's exported display data and draws to HTML5 Canvas
        // ================================================================
        var lastFrameCount = 0;
        var totalFrames = 0;
        var canvasCtx = document.getElementById('canvas').getContext('2d');

        function renderLoop() {
            if (!runtimeReady) return;

            try {
                var frameCount = Module._pebble_display_frame_count();
                if (frameCount === lastFrameCount) return;
                lastFrameCount = frameCount;
                totalFrames++;

                var width = Module._pebble_display_width();
                var height = Module._pebble_display_height();
                var stride = Module._pebble_display_stride();
                var dataPtr = Module._pebble_display_data();

                if (!dataPtr || !width || !height) return;

                if (totalFrames === 1) {
                    setStatus('Display active: ' + width + 'x' + height);
                }

                var imgData = canvasCtx.createImageData(width, height);
                var pixels = imgData.data;

                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var srcOff = dataPtr + y * stride + x * 4;
                        var dstOff = (y * width + x) * 4;
                        // QEMU DisplaySurface: BGRX (32bpp, blue in byte 0)
                        pixels[dstOff + 0] = Module.HEAPU8[srcOff + 2]; // R
                        pixels[dstOff + 1] = Module.HEAPU8[srcOff + 1]; // G
                        pixels[dstOff + 2] = Module.HEAPU8[srcOff + 0]; // B
                        pixels[dstOff + 3] = 255;                       // A
                    }
                }
                canvasCtx.putImageData(imgData, 0, 0);
            } catch(e) {
                // Ignore errors during early boot
            }
        }
        // Use setInterval — Emscripten's PROXY_TO_PTHREAD hijacks rAF
        setInterval(renderLoop, 50);

        // ================================================================
        // Button input
        // Sends button bitmask to QEMU via exported pebble_set_buttons()
        // Bit 0=back, 1=up, 2=select, 3=down
        // ================================================================
        var buttonState = 0;
        var BUTTON_BACK   = 1 << 0;
        var BUTTON_UP     = 1 << 1;
        var BUTTON_SELECT = 1 << 2;
        var BUTTON_DOWN   = 1 << 3;

        var keyMap = {
            'Escape':     BUTTON_BACK,
            'Backspace':  BUTTON_BACK,
            'ArrowUp':    BUTTON_UP,
            'ArrowDown':  BUTTON_DOWN,
            'Enter':      BUTTON_SELECT,
            'ArrowRight': BUTTON_SELECT,
            'ArrowLeft':  BUTTON_BACK,
            'q':          BUTTON_BACK,
            'w':          BUTTON_UP,
            's':          BUTTON_SELECT,
            'x':          BUTTON_DOWN,
        };

        var buttonStateAddr = 0; // HEAPU32 index, resolved lazily

        function updateButtons(bit, pressed) {
            if (pressed) {
                buttonState |= bit;
            } else {
                buttonState &= ~bit;
            }
            if (!runtimeReady) return;
            // Write directly to WASM shared memory for instant cross-thread
            // visibility (the proxied Module._pebble_set_buttons call has
            // multi-second latency under PROXY_TO_PTHREAD + TCI)
            if (buttonStateAddr) {
                Atomics.store(Module.HEAPU32, buttonStateAddr, buttonState);
            } else if (Module._pebble_button_state_addr) {
                var addr = Module._pebble_button_state_addr();
                if (addr) {
                    buttonStateAddr = addr >> 2;
                    Atomics.store(Module.HEAPU32, buttonStateAddr, buttonState);
                    log('[button] Direct memory at 0x' + addr.toString(16));
                }
            }
        }

        // Keyboard events need a minimum hold time because the emulated
        // CPU runs slower than real-time under TCI. A brief keydown+keyup
        // can be missed if the firmware hasn't serviced the GPIO interrupt.
        var keyHoldTimers = {};

        document.addEventListener('keydown', function(e) {
            var bit = keyMap[e.key];
            if (bit !== undefined) {
                e.preventDefault();
                if (e.repeat) return;
                updateButtons(bit, true);
                // Cancel any pending release for this key
                if (keyHoldTimers[e.key]) clearTimeout(keyHoldTimers[e.key]);
                keyHoldTimers[e.key] = null;
            }
        });

        document.addEventListener('keyup', function(e) {
            var bit = keyMap[e.key];
            if (bit !== undefined) {
                e.preventDefault();
                // Delay release to ensure firmware sees the press
                if (keyHoldTimers[e.key]) clearTimeout(keyHoldTimers[e.key]);
                keyHoldTimers[e.key] = setTimeout(function() {
                    updateButtons(bit, false);
                    keyHoldTimers[e.key] = null;
                }, 1000);
            }
        });

        // Mouse/touch button support
        var btnMap = {
            'btn-back':   BUTTON_BACK,
            'btn-up':     BUTTON_UP,
            'btn-select': BUTTON_SELECT,
            'btn-down':   BUTTON_DOWN,
        };

        Object.keys(btnMap).forEach(function(id) {
            var el = document.getElementById(id);
            var bit = btnMap[id];
            el.addEventListener('mousedown', function(e) {
                e.preventDefault();
                el.classList.add('pressed');
                updateButtons(bit, true);
            });
            el.addEventListener('mouseup', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
            el.addEventListener('mouseleave', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
            el.addEventListener('touchstart', function(e) {
                e.preventDefault();
                el.classList.add('pressed');
                updateButtons(bit, true);
            });
            el.addEventListener('touchend', function(e) {
                el.classList.remove('pressed');
                updateButtons(bit, false);
            });
        });
    </script>
</body>
</html>
